{"meta":{"title":"指尖上的律动","subtitle":"Always on the way of programming.","description":"记录自己学习成长的点滴。","author":"明月天涯","url":"http://www.mikewoo.top"},"pages":[{"title":"about","date":"2018-08-14T03:07:14.000Z","updated":"2018-08-14T05:24:47.919Z","comments":false,"path":"about/index.html","permalink":"http://www.mikewoo.top/about/index.html","excerpt":"","text":"关于我一介书生，在编程的路上继续前行，关注微服务、大数据、机器学习领域新的潮流。 From: 明月天涯 Github: https://github.com/mikewooBlog: https://mikewoo.github.ioEmail: ahqsgmm@gmail.com"},{"title":"categories","date":"2018-08-14T03:06:56.000Z","updated":"2018-09-11T07:31:41.260Z","comments":false,"path":"categories/index.html","permalink":"http://www.mikewoo.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-14T03:11:33.000Z","updated":"2018-09-11T07:31:17.249Z","comments":false,"path":"tags/index.html","permalink":"http://www.mikewoo.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入学习Netty-Socket服务器与客户端示例","slug":"深入学习Netty-Socket服务器与客户端示例","date":"2018-11-14T05:27:09.000Z","updated":"2018-11-14T07:42:09.781Z","comments":true,"path":"2018/11/14/深入学习Netty-Socket服务器与客户端示例/","link":"","permalink":"http://www.mikewoo.top/2018/11/14/深入学习Netty-Socket服务器与客户端示例/","excerpt":"在了解了Netty是什么以及它的基本组件之后，我们接下来看看Netty在实际工作中如何应用。本节主要关注基于Netty如何实现Socket服务器和客户端。","text":"在了解了Netty是什么以及它的基本组件之后，我们接下来看看Netty在实际工作中如何应用。本节主要关注基于Netty如何实现Socket服务器和客户端。 Netty在实际工作中的应用在互联网行业，随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。典型的应用有：阿里分布式服务框架Dubbo底层就使用Netty进行节点间通信，Dubbo默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。 在游戏游戏行业，无论是手游服务端、还是大型的网络游戏，Java 语言得到了越来越广泛的应用。Netty 作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信。 总的来说，Netty在实际工作中的应用大体可以分为以下三类： 作为RPC框架的基础通信组件，实现RPC框架各节点之间的通信。这应该是Netty应用最多的一方面，实际底层就是基于Socket通信，来实现远程过程调用。 通过对WebSocket的支持，实现基于WebSocket协议的长连接服务器。WebSocket是一种规范，是Html5规范的一部分，可以实现在单个TCP连接上进行全双工通讯，WebSocket协议使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。Netty对WebSocket细节进行了实现，通过这种方式，就可以实现服务端主动往客户端发送消息的功能。 作为HTTP服务器。Netty支持HTTP协议，对于Netty 提供了codec编解码器支持，使得Netty客户端、服务端支持HTTP ，只需要添加相应的Http codc即可，十分简便。并支持SSL/TLS，可实现通过SSL/TLS进行安全传输。 Netty实现Socket客户端和服务器本节主要介绍基于Netty如何实现Socket服务器和客户端，服务器示例代码如下。1234567891011121314151617181920212223242526272829303132333435import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;/** * @author Eric Gui * @date 2018/9/26 */public class TestSocketServer &#123; public static void main(String[] args) &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.DEBUG)) .childHandler(new TestServerChannelInitializer()); ChannelFuture channelFuture = serverBootstrap.bind(8899).sync(); channelFuture.channel().closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; 服务端首先创建两个EventLoopGroup，其中： bossGroup：用于接收客户端的连接，连接建立后，bossGroup 就不会在对其进行处理，转而交由workerGroup 处理；workerGroup：真正完成客户端连接上IO数据的处理。","categories":[{"name":"深入学习Netty","slug":"深入学习Netty","permalink":"http://www.mikewoo.top/categories/深入学习Netty/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://www.mikewoo.top/tags/TCP/"},{"name":"Netty","slug":"Netty","permalink":"http://www.mikewoo.top/tags/Netty/"},{"name":"Socket","slug":"Socket","permalink":"http://www.mikewoo.top/tags/Socket/"}]},{"title":"广播地址计算","slug":"广播地址计算","date":"2018-11-14T02:47:02.000Z","updated":"2018-11-14T03:23:00.008Z","comments":true,"path":"2018/11/14/广播地址计算/","link":"","permalink":"http://www.mikewoo.top/2018/11/14/广播地址计算/","excerpt":"学过计算机网络的同学都知道，IP地址是互联网上每个子网或每个主机在网络上的唯一身份标签，在设置电脑IP时，会碰到两个重要的参数，一个是IP地址，一个是子网掩码。IP地址大家很熟悉，子网掩码是什么呢，又有什么作用呢？除此之外还有广播地址，它又有什么作用呢？","text":"学过计算机网络的同学都知道，IP地址是互联网上每个子网或每个主机在网络上的唯一身份标签，在设置电脑IP时，会碰到两个重要的参数，一个是IP地址，一个是子网掩码。IP地址大家很熟悉，子网掩码是什么呢，又有什么作用呢？除此之外还有广播地址，它又有什么作用呢？ 子网掩码介绍子网掩码 (subnet mask) 又叫网络掩码、地址掩码、子网络遮罩，是一个应用于 TCP/IP 网络的 32 位二进制值。它可以屏蔽掉 IP 地址中的一部分，从而分离出 IP 地址中的网络部分与主机部分，基于子网掩码，管理员可以将网络进一步划分为若干子网。它必须结合 IP 地址一起使用。 虽然我们说子网掩码可以分离出 IP 地址中的网络部分与主机部分，可大家还是会有疑问，比如为什么要区分网络地址与主机地址？区分以后又怎样呢？那么好，让我们再详细的讲一下吧！ 在使用 TCP/IP 协议的两台计算机之间进行通信时，我们通过将本机的子网掩码与接受方主机的 IP 地址进行“与”运算，即可得到目标主机所在的网络号，又由于每台主机在配置 TCP/IP 协议时都设置了一个本机 IP 地址与子网掩码，所以可以知道本机所在的网络号。 通过比较这两个网络号，就可以知道接受方主机是否在本网络上。如果网络号相同，表明接受方在本网络上，那么可以通过相关的协议把数据包直接发送到目标主机；如果网络号不同，表明目标主机在远程网络上，那么数据包将会发送给本网络上的路由器，由路由器将数据包发送到其他网络，直至到达目的地。在这个过程中你可以看到，子网掩码是不可或缺的！ 广播地址介绍广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。如192.168.1.255就是C类地址中的一个广播地址，你将信息发送到此地址，就是将信息发送给网络号为192.168.1的所有主机。 已知IP地址和子网掩码求广播地址在实际工作中，已知IP地址和子网掩码，怎么求广播地址呢？以个人云主机内网为例，IP地址为172.31.172.142，子网掩码为255.255.240.0，则本网段广播地址是多少呢？ 广播地址计算方法 把点分十进制的子网掩码地址换算成二进制255.255.240.0 ==&gt; 1111 1111 . 1111 1111 . 1111 0000 . 0000 0000发现子网掩码有20个连续1，所以前20位作为网络地址，后12位作为主机地址。所以IP地址也可以表示为172.31.172.142/22，与IP地址和子网掩码分开表示方式等价。 把IP地址跟子网掩码取与（&amp;）得到网络地址 12345172.31.172.142 ==&gt; 1010 1100 . 0001 1111 . 1010 1100 . 1000 1110&amp;255.255.240.0 ==&gt; 1111 1111 . 1111 1111 . 1111 0000 . 0000 0000=172.31.160.0 ==&gt; 1010 1100 . 0001 1111 . 1010 0000 . 0000 0000 计算得到网络地址为172.31.160.0。 根据网络地址计算广播地址广播地址是网络地址的主机位全1，也就是172.31.160.0的后12位全变1就是广播地址.1010 1100 . 0001 1111 . 1010 0000 . 0000 0000后12位全变为1，得到1010 1100 . 0001 1111 . 1010 1111 . 1111 1111所以计算的到该网络对应的广播地址为：172.31.175.255","categories":[{"name":"网络编程","slug":"网络编程","permalink":"http://www.mikewoo.top/categories/网络编程/"}],"tags":[{"name":"IP","slug":"IP","permalink":"http://www.mikewoo.top/tags/IP/"},{"name":"BROADCAST","slug":"BROADCAST","permalink":"http://www.mikewoo.top/tags/BROADCAST/"}]},{"title":"深入学习Netty-认识Netty","slug":"深入学习Netty-认识Netty","date":"2018-09-11T07:29:46.000Z","updated":"2018-09-11T09:46:00.142Z","comments":true,"path":"2018/09/11/深入学习Netty-认识Netty/","link":"","permalink":"http://www.mikewoo.top/2018/09/11/深入学习Netty-认识Netty/","excerpt":"Netty是什么Netty是由JBOSS提供的一个Java开源网络应用框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。","text":"Netty是什么Netty是由JBOSS提供的一个Java开源网络应用框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 Netty提供了一种新的方式来开发网络应用程序，这种新的方式使它很容易使用和具有很强的扩展性。Netty的内部实现是很复杂的，但是Netty封装了JDK底层BIO和NIO模型，提供了简单易用的API，同时Netty自带编解码器解决拆包粘包问题，实现了网络处理中逻辑解耦，让用户只用关心实际的业务逻辑。 Netty是完全基于NIO实现的，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。 Netty是当前非常流行的NIO框架，它的健壮性、高性能、可定制性以及可扩展性在同类框架都是首屈一指的。业界很多著名的开源框架都是基于Netty构建，如主流的RPC通信框架Dubbo、消息中间件RocketMQ、分布式协调服务Zookeeper、Hadoop的RPC框架Avro等等。 那么Netty的性能为什么会这么高呢？主要是因为其内部Reactor模型的实现。 Reactor模型Reactor设计模式是Event-Driven Drchitecture的一种实现方式，用以处理多个客户端并发的向服务端请求服务的场景。 何为Reactor线程模型Reactor模式是事件驱动的，Wikipedia上说：“The reactor design pattern is an event handling pattern for handling service requests delivered concurrently by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to associated request handlers.”。从这个描述中，我们知道Reactor模式首先是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler。 从结构上，这有点类似生产者消费者模式，即有一个或多个生产者将事件放入一个Queue中，而一个或多个消费者主动的从这个Queue中Poll事件来处理；而Reactor模式则并没有Queue来做缓冲，每当一个Event输入到Service Handler之后，该Service Handler会立刻的根据不同的Event类型将其分发给对应的Request Handler来处理。 Netty的Reactor线程模型Netty的Reactor模型主要由多路复用器(Acceptor)、事件分发器(Dispatcher)、事件处理器(Handler)三部分组成，Netty中典型的实现有三种： 1. 单线程模型单线程模型是最简单的Reactor模型，所有I/O操作都由一个线程完成，即多路分离套接字、Accept新连接和新连接数据处理都是在一个Reactor线程上完成的。 对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的场景，由于是单线程，无法处理成百上千的连接，另外无法使用多核资源，实际中少使用。 2. 多线程模型为了解决单线程模型存在的一些问题，演化出来Reactor多线程模型。 多线程模型有如下特点： 有一个专门的Acceptor线程用于监听服务端，接收客户端的TCP连接请求； 所有的网络IO读写操作都是由一个专门的NIO线程池负责，将Accept新连接和事件处理分开，由这些NIO线程负责消息的读取、解码、编码和发送； 一个NIO线程可以同时处理多条链路，但是一个链路只能对应一个NIO线程，防止发生并发操作问题。 在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，在极特殊应用场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如百万客户端并发连接，或者服务端需要对客户端的握手消息进行安全认证，认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型-主从Reactor多线程模型。 3. 主从多线程模型主从多线程模型中接收客户端连接的不再是1个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到I/O线程池（sub reactor线程池）的某个I/O线程上，由它负责SocketChannel的读写和编解码工作。 通常Acceptor线程池只用于客户端的登录、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的I/O线程上，由I/O线程负责后续的I/O操作。 第三种模型比起第二种模型，是将Reactor分成两部分，mainReactor负责监听server socket，accept新连接，并将建立的socket分派给subReactor。subReactor负责多路分离已连接的socket，读写网 络数据，对业务处理功能，其扔给worker线程池完成。通常，subReactor个数上可与CPU个数等同。 事实上，Netty的线程模型并非固定不变，在启动辅助类中创建不同的EventLoopGroup实例并通过适当的参数配置，就可以支持上述三种Reactor线程模型。正是因为Netty对Reactor线程模型的支持提供了灵活的定制能力，所以可以满足不同业务场景的性能需求。 Netty核心组件Netty中的核心组件包括Channel、EventLoop、ChannelHandler、ChannelPipeLine、ByteBuf、Bootstrap、ServerBootstrap。 Channel在Netty里，Channel是通讯的载体，Channel代表一个Socker链接或者其他的IO相关组件。Channel用于完成基础的IO操作，如绑定、连接、读写等，Channel提供了一组API，极大地简化了直接与Socket进行操作的复杂性 EventLoopEventLoop是一个事件循环，可以理解为一个线程，用来处理连接的生命周期中所发生的事件，如服务端接受客户端连接的接入，处理每个已接入连接上数据流的读写。EventLoop定义了处理在连接过程中发生的事件的核心抽象，一个EventLoop可以为多个Channel服务。 ChannelHandler从应用开发者看来，ChannelHandler是最重要的组件，其中存放用来处理进站和出站数据的用户逻辑。ChannelHandler的方法被网络事件触发，ChannelHandler可以用于几乎任何类型的操作，如将数据从一种格式转换为另一种格式或处理抛出的异常。例如，其子接口ChannelInboundHandler，接受进站的事件和数据以便被用户定义的逻辑处理，或者当响应所连接的客户端时刷新ChannelInboundHandler的数据。 ChannelPipeLineNetty 在事件处理上，是通过ChannelPipeline来控制事件流，通过调用注册其上的一系列ChannelHandler来处理事件。ChannelPipeline为ChannelHandler链提供了一个容器并定义了用于沿着链传播入站和出站事件流的API。当创建Channel时，会自动创建一个附属的ChannelPipeline。数据可以沿着处理链进行传递。 ByteBufByteBuf是一个存储字节的容器，是对JDK底层NIO中ByteBuffer的封装，最大特点就是使用方便，它既有自己的读索引和写索引，方便你对整段字节缓存进行读写，也支持get/set，方便你对其中每一个字节进行读写。通常有Heap Buffer、Direct Buffer、Composite Buffer三种模式。其中Direct Buffer是ByteBuf中一种常用模式，它的内存分配都发生在堆外的直接内存中，免去了中间交换的内存拷贝, 提升IO处理速度。 Bootstrap 和 ServerBootstrapBootstrap 和 ServerBootstrap是创建Netty客户端和服务端的引导辅助类，负责服务端和客户端创建以及初始化时的一些参数设置，如指定Channel类型，配置ChannelHandler等。 参考资料 Netty入门简介 Netty入门教程 Netty中的基本组件及关系","categories":[{"name":"深入学习Netty","slug":"深入学习Netty","permalink":"http://www.mikewoo.top/categories/深入学习Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://www.mikewoo.top/tags/Netty/"},{"name":"NIO","slug":"NIO","permalink":"http://www.mikewoo.top/tags/NIO/"},{"name":"Reactor","slug":"Reactor","permalink":"http://www.mikewoo.top/tags/Reactor/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-14T02:46:25.000Z","updated":"2018-09-11T09:49:49.131Z","comments":true,"path":"2018/08/14/hello-world/","link":"","permalink":"http://www.mikewoo.top/2018/08/14/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://www.mikewoo.top/categories/博客搭建/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.mikewoo.top/tags/Hexo/"},{"name":"github","slug":"github","permalink":"http://www.mikewoo.top/tags/github/"}]}]}